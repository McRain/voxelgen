"use strict";(self.webpackChunkvoxel_creator=self.webpackChunkvoxel_creator||[]).push([[489],{302:(t,e,n)=>{n.d(e,{A:()=>c});const r={},o={},s=(t,e,n)=>{null==o[t]&&(o[t]=[]),o[t].push({handler:n,once:e})};class i{static Add(t){for(const[e,n]of Object.entries(t))r[e]=n,i.Emit("add",e,n)}static Remove(t){if(!r[t])return;const e=r[t];delete r[t],i.Emit("remove",t,e)}static Init(t){return t&&i.Add(t),i.Emit("init"),a}static On(t,e){s(t,!1,e)}static Once(t,e){s(t,!0,e)}static Off(t,e){const n=o[t];if(n){for(let t=n.length-1;t>=0;t--)n[t].handler===e&&n.splice(t,1);0===n.length&&delete o[t]}}static async Emit(t,...e){const n=o[t];if(null==n)return;const r=[];for(let t=n.length-1;t>=0;t--){const o=n[t];r.push(o.handler.apply(null,e)),o.once&&n.splice(t,1)}await Promise.allSettled(r)}}const a=new Proxy(i,{get:(t,e)=>e in t?t[e]:r[e]}),c=792==n.j?a:null},409:(t,e,n)=>{n.d(e,{K5:()=>B,LO:()=>x,Of:()=>b,je:()=>w,zQ:()=>y});var r=n(922);if(792==n.j)var o=n(659);if(792==n.j)var s=n(747);const i=parseInt(r.sPf)>=166,a=new r.RlV,c=new r.Pq0,l=new r.kn4,u=r.eaF.prototype.raycast,f=r.$Ed.prototype.raycast,d=new r.Pq0,p=new r.eaF,h=792==n.j?[]:null;function y(t,e){this.isBatchedMesh?g.call(this,t,e):m.call(this,t,e)}function g(t,e){if(this.boundsTrees){const n=this.boundsTrees,o=this._drawInfo||this._instanceInfo,s=this._drawRanges||this._geometryInfo,i=this.matrixWorld;p.material=this.material,p.geometry=this.geometry;const a=p.geometry.boundsTree,c=p.geometry.drawRange;null===p.geometry.boundingSphere&&(p.geometry.boundingSphere=new r.iyt);for(let r=0,a=o.length;r<a;r++){if(!this.getVisibleAt(r))continue;const a=o[r].geometryIndex;if(p.geometry.boundsTree=n[a],this.getMatrixAt(r,p.matrixWorld).premultiply(i),!p.geometry.boundsTree){this.getBoundingBoxAt(a,p.geometry.boundingBox),this.getBoundingSphereAt(a,p.geometry.boundingSphere);const t=s[a];p.geometry.setDrawRange(t.start,t.count)}p.raycast(t,h);for(let t=0,n=h.length;t<n;t++){const n=h[t];n.object=this,n.batchId=r,e.push(n)}h.length=0}p.geometry.boundsTree=a,p.geometry.drawRange=c,p.material=null,p.geometry=null}else f.call(this,t,e)}function m(t,e){if(this.geometry.boundsTree){if(void 0===this.material)return;l.copy(this.matrixWorld).invert(),a.copy(t.ray).applyMatrix4(l),d.setFromMatrixScale(this.matrixWorld),c.copy(a.direction).multiply(d);const n=c.length(),r=t.near/n,s=t.far/n,i=this.geometry.boundsTree;if(!0===t.firstHitOnly){const n=(0,o.s)(i.raycastFirst(a,this.material,r,s),this,t);n&&e.push(n)}else{const n=i.raycast(a,this.material,r,s);for(let r=0,s=n.length;r<s;r++){const s=(0,o.s)(n[r],this,t);s&&e.push(s)}}}else u.call(this,t,e)}function x(t={}){return this.boundsTree=new s.G(this,t),this.boundsTree}function w(){this.boundsTree=null}function B(t=-1,e={}){if(!i)throw new Error("BatchedMesh: Three r166+ is required to compute bounds trees.");e.indirect&&console.warn('"Indirect" is set to false because it is not supported for BatchedMesh.'),e={...e,indirect:!1,range:null};const n=this._drawRanges||this._geometryInfo,r=this._geometryCount;this.boundsTrees||(this.boundsTrees=new Array(r).fill(null));const o=this.boundsTrees;for(;o.length<r;)o.push(null);if(t<0){for(let t=0;t<r;t++)e.range=n[t],o[t]=new s.G(this.geometry,e);return o}return t<n.length&&(e.range=n[t],o[t]=new s.G(this.geometry,e)),o[t]||null}function b(t=-1){t<0?this.boundsTrees.fill(null):t<this.boundsTree.length&&(this.boundsTrees[t]=null)}},659:(t,e,n)=>{function r(t,e,n){return null===t?null:(t.point.applyMatrix4(e.matrixWorld),t.distance=t.point.distanceTo(n.ray.origin),t.object=e,t)}n.d(e,{s:()=>r})},747:(t,e,n)=>{n.d(e,{G:()=>Ae});var r=n(922);const o=1.25,s=65535,i=Math.pow(2,-24),a=Symbol("SKIP_GENERATION");function c(t){return function(t){return t.index?t.index.count:t.attributes.position.count}(t)/3}function l(t,e){const n=c(t),r=e||t.drawRange,o=r.start/3,s=(r.start+r.count)/3,i=Math.max(0,o),a=Math.min(n,s)-i;return[{offset:Math.floor(i),count:Math.floor(a)}]}function u(t,e){if(!t.groups||!t.groups.length)return l(t,e);const n=[],r=new Set,o=e||t.drawRange,s=o.start/3,i=(o.start+o.count)/3;for(const e of t.groups){const t=e.start/3,n=(e.start+e.count)/3;r.add(Math.max(s,t)),r.add(Math.min(i,n))}const a=Array.from(r.values()).sort((t,e)=>t-e);for(let t=0;t<a.length-1;t++){const e=a[t],r=a[t+1];n.push({offset:Math.floor(e),count:Math.floor(r-e)})}return n}function f(t,e,n,r,o){let s=1/0,i=1/0,a=1/0,c=-1/0,l=-1/0,u=-1/0,f=1/0,d=1/0,p=1/0,h=-1/0,y=-1/0,g=-1/0;for(let r=6*e,o=6*(e+n);r<o;r+=6){const e=t[r+0],n=t[r+1],o=e-n,m=e+n;o<s&&(s=o),m>c&&(c=m),e<f&&(f=e),e>h&&(h=e);const x=t[r+2],w=t[r+3],B=x-w,b=x+w;B<i&&(i=B),b>l&&(l=b),x<d&&(d=x),x>y&&(y=x);const P=t[r+4],A=t[r+5],T=P-A,v=P+A;T<a&&(a=T),v>u&&(u=v),P<p&&(p=P),P>g&&(g=P)}r[0]=s,r[1]=i,r[2]=a,r[3]=c,r[4]=l,r[5]=u,o[0]=f,o[1]=d,o[2]=p,o[3]=h,o[4]=y,o[5]=g}function d(t,e,n){return n.min.x=e[t],n.min.y=e[t+1],n.min.z=e[t+2],n.max.x=e[t+3],n.max.y=e[t+4],n.max.z=e[t+5],n}function p(t){let e=-1,n=-1/0;for(let r=0;r<3;r++){const o=t[r+3]-t[r];o>n&&(n=o,e=r)}return e}function h(t,e){e.set(t)}function y(t,e,n){let r,o;for(let s=0;s<3;s++){const i=s+3;r=t[s],o=e[s],n[s]=r<o?r:o,r=t[i],o=e[i],n[i]=r>o?r:o}}function g(t,e,n){for(let r=0;r<3;r++){const o=e[t+2*r],s=e[t+2*r+1],i=o-s,a=o+s;i<n[r]&&(n[r]=i),a>n[r+3]&&(n[r+3]=a)}}function m(t){const e=t[3]-t[0],n=t[4]-t[1],r=t[5]-t[2];return 2*(e*n+n*r+r*e)}const x=(t,e)=>t.candidate-e.candidate,w=new Array(32).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),B=new Float32Array(6);class b{constructor(){this.boundingData=new Float32Array(6)}}function P(t,e,n,r,o,s){let i=r,a=r+o-1;const c=s.pos,l=2*s.axis;for(;;){for(;i<=a&&n[6*i+l]<c;)i++;for(;i<=a&&n[6*a+l]>=c;)a--;if(!(i<a))return i;for(let t=0;t<3;t++){let n=e[3*i+t];e[3*i+t]=e[3*a+t],e[3*a+t]=n}for(let t=0;t<6;t++){let e=n[6*i+t];n[6*i+t]=n[6*a+t],n[6*a+t]=e}i++,a--}}function A(t,e,n,r,o,s){let i=r,a=r+o-1;const c=s.pos,l=2*s.axis;for(;;){for(;i<=a&&n[6*i+l]<c;)i++;for(;i<=a&&n[6*a+l]>=c;)a--;if(!(i<a))return i;{let e=t[i];t[i]=t[a],t[a]=e;for(let t=0;t<6;t++){let e=n[6*i+t];n[6*i+t]=n[6*a+t],n[6*a+t]=e}i++,a--}}}function T(t,e){return 65535===e[t+15]}function v(t,e){return e[t+6]}function M(t,e){return e[t+14]}function q(t){return t+8}function U(t,e){return e[t+6]}function S(t,e){return e[t+7]}function I(t){return t}let _,F,R,z;const V=Math.pow(2,32);function C(t){return"count"in t?1:1+C(t.left)+C(t.right)}function E(t,e,n){return _=new Float32Array(n),F=new Uint32Array(n),R=new Uint16Array(n),z=new Uint8Array(n),N(t,e)}function N(t,e){const n=t/4,r=t/2,o="count"in e,i=e.boundingData;for(let t=0;t<6;t++)_[n+t]=i[t];if(o){if(e.buffer){const r=e.buffer;z.set(new Uint8Array(r),t);for(let e=t,o=t+r.byteLength;e<o;e+=32)T(e/2,R)||(F[e/4+6]+=n);return t+r.byteLength}{const o=e.offset,i=e.count;return F[n+6]=o,R[r+14]=i,R[r+15]=s,t+32}}{const r=e.left,o=e.right,s=e.splitAxis;let i;if(i=N(t+32,r),i/4>V)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return F[n+6]=i/4,i=N(i,o),F[n+7]=s,i}}function Y(t,e){const n=t.geometry;e.indirect&&(t._indirectBuffer=function(t,e){const n=(t.index?t.index.count:t.attributes.position.count)/3,r=n>65536,o=r?4:2,s=e?new SharedArrayBuffer(n*o):new ArrayBuffer(n*o),i=r?new Uint32Array(s):new Uint16Array(s);for(let t=0,e=i.length;t<e;t++)i[t]=t;return i}(n,e.useSharedArrayBuffer),function(t,e){const n=c(t),r=u(t,e).sort((t,e)=>t.offset-e.offset),o=r[r.length-1];o.count=Math.min(n-o.offset,o.count);let s=0;return r.forEach(({count:t})=>s+=t),n!==s}(n,e.range)&&!e.verbose&&console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),t._indirectBuffer||function(t,e){if(!t.index){const n=t.attributes.position.count,o=function(t,e=ArrayBuffer){return t>65535?new Uint32Array(new e(4*t)):new Uint16Array(new e(2*t))}(n,e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer);t.setIndex(new r.THS(o,1));for(let t=0;t<n;t++)o[t]=t}}(n,e);const s=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,a=function(t,e=null,n=null,r=null){const o=t.attributes.position,s=t.index?t.index.array:null,a=c(t),l=o.normalized;let u;null===e?(u=new Float32Array(6*a),n=0,r=a):(u=e,n=n||0,r=r||a);const f=o.array,d=o.offset||0;let p=3;o.isInterleavedBufferAttribute&&(p=o.data.stride);const h=["getX","getY","getZ"];for(let t=n;t<n+r;t++){const e=3*t,n=6*t;let r=e+0,a=e+1,c=e+2;s&&(r=s[r],a=s[a],c=s[c]),l||(r=r*p+d,a=a*p+d,c=c*p+d);for(let t=0;t<3;t++){let e,s,d;l?(e=o[h[t]](r),s=o[h[t]](a),d=o[h[t]](c)):(e=f[r+t],s=f[a+t],d=f[c+t]);let p=e;s<p&&(p=s),d<p&&(p=d);let y=e;s>y&&(y=s),d>y&&(y=d);const g=(y-p)/2,m=2*t;u[n+m+0]=p+g,u[n+m+1]=g+(Math.abs(p)+g)*i}}return u}(n),d=e.indirect?l(n,e.range):u(n,e.range);t._roots=d.map(n=>{const r=function(t,e,n,r,s){const{maxDepth:i,verbose:a,maxLeafTris:l,strategy:u,onProgress:d,indirect:T}=s,v=t._indirectBuffer,M=t.geometry,q=M.index?M.index.array:null,U=T?A:P,S=c(M),I=new Float32Array(6);let _=!1;const F=new b;return f(e,n,r,F.boundingData,I),function t(n,r,s,c=null,d=0){if(!_&&d>=i&&(_=!0,a&&(console.warn(`MeshBVH: Max depth of ${i} reached when generating BVH. Consider increasing maxDepth.`),console.warn(M))),s<=l||d>=i)return R(r+s),n.offset=r,n.count=s,n;const P=function(t,e,n,r,s,i){let a=-1,c=0;if(0===i)a=p(e),-1!==a&&(c=(e[a]+e[a+3])/2);else if(1===i)a=p(t),-1!==a&&(c=function(t,e,n,r){let o=0;for(let s=e,i=e+n;s<i;s++)o+=t[6*s+2*r];return o/n}(n,r,s,a));else if(2===i){const i=m(t);let l=o*s;const u=6*r,f=6*(r+s);for(let t=0;t<3;t++){const r=e[t],d=(e[t+3]-r)/32;if(s<8){const e=[...w];e.length=s;let r=0;for(let o=u;o<f;o+=6,r++){const s=e[r];s.candidate=n[o+2*t],s.count=0;const{bounds:i,leftCacheBounds:a,rightCacheBounds:c}=s;for(let t=0;t<3;t++)c[t]=1/0,c[t+3]=-1/0,a[t]=1/0,a[t+3]=-1/0,i[t]=1/0,i[t+3]=-1/0;g(o,n,i)}e.sort(x);let d=s;for(let t=0;t<d;t++){const n=e[t];for(;t+1<d&&e[t+1].candidate===n.candidate;)e.splice(t+1,1),d--}for(let r=u;r<f;r+=6){const o=n[r+2*t];for(let t=0;t<d;t++){const s=e[t];o>=s.candidate?g(r,n,s.rightCacheBounds):(g(r,n,s.leftCacheBounds),s.count++)}}for(let n=0;n<d;n++){const r=e[n],u=r.count,f=s-r.count,d=r.leftCacheBounds,p=r.rightCacheBounds;let h=0;0!==u&&(h=m(d)/i);let y=0;0!==f&&(y=m(p)/i);const g=1+o*(h*u+y*f);g<l&&(a=t,l=g,c=r.candidate)}}else{for(let t=0;t<32;t++){const e=w[t];e.count=0,e.candidate=r+d+t*d;const n=e.bounds;for(let t=0;t<3;t++)n[t]=1/0,n[t+3]=-1/0}for(let e=u;e<f;e+=6){let o=~~((n[e+2*t]-r)/d);o>=32&&(o=31);const s=w[o];s.count++,g(e,n,s.bounds)}const e=w[31];h(e.bounds,e.rightCacheBounds);for(let t=30;t>=0;t--){const e=w[t],n=w[t+1];y(e.bounds,n.rightCacheBounds,e.rightCacheBounds)}let p=0;for(let e=0;e<31;e++){const n=w[e],r=n.count,u=n.bounds,f=w[e+1].rightCacheBounds;0!==r&&(0===p?h(u,B):y(u,B,B)),p+=r;let d=0,g=0;0!==p&&(d=m(B)/i);const x=s-p;0!==x&&(g=m(f)/i);const b=1+o*(d*p+g*x);b<l&&(a=t,l=b,c=n.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${i} used.`);return{axis:a,pos:c}}(n.boundingData,c,e,r,s,u);if(-1===P.axis)return R(r+s),n.offset=r,n.count=s,n;const A=U(v,q,e,r,s,P);if(A===r||A===r+s)R(r+s),n.offset=r,n.count=s;else{n.splitAxis=P.axis;const o=new b,i=r,a=A-r;n.left=o,f(e,i,a,o.boundingData,I),t(o,i,a,I,d+1);const c=new b,l=A,u=s-a;n.right=c,f(e,l,u,c.boundingData,I),t(c,l,u,I,d+1)}return n}(F,n,r,I),F;function R(t){d&&d(t/S)}}(t,a,n.offset,n.count,e),i=C(r),l=new s(32*i);return E(0,r,l),l})}class k{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,r=-1/0;for(let o=0,s=t.length;o<s;o++){const s=t[o][e];n=s<n?s:n,r=s>r?s:r}this.min=n,this.max=r}setFromPoints(t,e){let n=1/0,r=-1/0;for(let o=0,s=e.length;o<s;o++){const s=e[o],i=t.dot(s);n=i<n?i:n,r=i>r?i:r}this.min=n,this.max=r}isSeparated(t){return this.min>t.max||t.min>this.max}}k.prototype.setFromBox=function(){const t=new r.Pq0;return function(e,n){const r=n.min,o=n.max;let s=1/0,i=-1/0;for(let n=0;n<=1;n++)for(let a=0;a<=1;a++)for(let c=0;c<=1;c++){t.x=r.x*n+o.x*(1-n),t.y=r.y*a+o.y*(1-a),t.z=r.z*c+o.z*(1-c);const l=e.dot(t);s=Math.min(l,s),i=Math.max(l,i)}this.min=s,this.max=i}}(),new k;const O=function(){const t=new r.Pq0,e=new r.Pq0,n=new r.Pq0;return function(r,o,s){const i=r.start,a=t,c=o.start,l=e;n.subVectors(i,c),t.subVectors(r.end,r.start),e.subVectors(o.end,o.start);const u=n.dot(l),f=l.dot(a),d=l.dot(l),p=n.dot(a),h=a.dot(a)*d-f*f;let y,g;y=0!==h?(u*f-p*d)/h:0,g=(u+y*f)/d,s.x=y,s.y=g}}(),Z=function(){const t=new r.I9Y,e=new r.Pq0,n=new r.Pq0;return function(r,o,s,i){O(r,o,t);let a=t.x,c=t.y;if(a>=0&&a<=1&&c>=0&&c<=1)return r.at(a,s),void o.at(c,i);if(a>=0&&a<=1)return c<0?o.at(0,i):o.at(1,i),void r.closestPointToPoint(i,!0,s);if(c>=0&&c<=1)return a<0?r.at(0,s):r.at(1,s),void o.closestPointToPoint(s,!0,i);{let t,l;t=a<0?r.start:r.end,l=c<0?o.start:o.end;const u=e,f=n;return r.closestPointToPoint(l,!0,e),o.closestPointToPoint(t,!0,n),u.distanceToSquared(l)<=f.distanceToSquared(t)?(s.copy(u),void i.copy(l)):(s.copy(t),void i.copy(f))}}}(),H=function(){const t=new r.Pq0,e=new r.Pq0,n=new r.Zcv,o=new r.cZY;return function(r,s){const{radius:i,center:a}=r,{a:c,b:l,c:u}=s;if(o.start=c,o.end=l,o.closestPointToPoint(a,!0,t).distanceTo(a)<=i)return!0;if(o.start=c,o.end=u,o.closestPointToPoint(a,!0,t).distanceTo(a)<=i)return!0;if(o.start=l,o.end=u,o.closestPointToPoint(a,!0,t).distanceTo(a)<=i)return!0;const f=s.getPlane(n);if(Math.abs(f.distanceToPoint(a))<=i){const t=f.projectPoint(a,e);if(s.containsPoint(t))return!0}return!1}}();function X(t){return Math.abs(t)<1e-15}class j extends r.lMl{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new r.Pq0),this.satBounds=new Array(4).fill().map(()=>new k),this.points=[this.a,this.b,this.c],this.sphere=new r.iyt,this.plane=new r.Zcv,this.needsUpdate=!0}intersectsSphere(t){return H(t,this)}update(){const t=this.a,e=this.b,n=this.c,r=this.points,o=this.satAxes,s=this.satBounds,i=o[0],a=s[0];this.getNormal(i),a.setFromPoints(i,r);const c=o[1],l=s[1];c.subVectors(t,e),l.setFromPoints(c,r);const u=o[2],f=s[2];u.subVectors(e,n),f.setFromPoints(u,r);const d=o[3],p=s[3];d.subVectors(n,t),p.setFromPoints(d,r),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(i,t),this.needsUpdate=!1}}j.prototype.closestPointToSegment=function(){const t=new r.Pq0,e=new r.Pq0,n=new r.cZY;return function(r,o=null,s=null){const{start:i,end:a}=r,c=this.points;let l,u=1/0;for(let i=0;i<3;i++){const a=(i+1)%3;n.start.copy(c[i]),n.end.copy(c[a]),Z(n,r,t,e),l=t.distanceToSquared(e),l<u&&(u=l,o&&o.copy(t),s&&s.copy(e))}return this.closestPointToPoint(i,t),l=i.distanceToSquared(t),l<u&&(u=l,o&&o.copy(t),s&&s.copy(i)),this.closestPointToPoint(a,t),l=a.distanceToSquared(t),l<u&&(u=l,o&&o.copy(t),s&&s.copy(a)),Math.sqrt(u)}}(),j.prototype.intersectsTriangle=function(){const t=new j,e=new Array(3),n=new Array(3),o=new k,s=new k,i=new r.Pq0,a=new r.Pq0,c=new r.Pq0,l=new r.Pq0,u=new r.Pq0,f=new r.cZY,d=new r.cZY,p=new r.cZY,h=new r.Pq0;function y(t,e,n){const r=t.points;let o=0,s=-1;for(let t=0;t<3;t++){const{start:i,end:c}=f;i.copy(r[t]),c.copy(r[(t+1)%3]),f.delta(a);const l=X(e.distanceToPoint(i));if(X(e.normal.dot(a))&&l){n.copy(f),o=2;break}const u=e.intersectLine(f,h);if(!u&&l&&h.copy(i),(u||l)&&!X(h.distanceTo(c))){if(o<=1)(1===o?n.start:n.end).copy(h),l&&(s=o);else if(o>=2){(1===s?n.start:n.end).copy(h),o=2;break}if(o++,2===o&&-1===s)break}}return o}return function(r,a=null,f=!1){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(t.copy(r),t.update(),r=t);const h=this.plane,g=r.plane;if(Math.abs(h.normal.dot(g.normal))>1-1e-10){const t=this.satBounds,c=this.satAxes;n[0]=r.a,n[1]=r.b,n[2]=r.c;for(let e=0;e<4;e++){const r=t[e],s=c[e];if(o.setFromPoints(s,n),r.isSeparated(o))return!1}const l=r.satBounds,u=r.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let t=0;t<4;t++){const n=l[t],r=u[t];if(o.setFromPoints(r,e),n.isSeparated(o))return!1}for(let t=0;t<4;t++){const r=c[t];for(let t=0;t<4;t++){const a=u[t];if(i.crossVectors(r,a),o.setFromPoints(i,e),s.setFromPoints(i,n),o.isSeparated(s))return!1}}return a&&(f||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),a.start.set(0,0,0),a.end.set(0,0,0)),!0}{const t=y(this,g,d);if(1===t&&r.containsPoint(d.end))return a&&(a.start.copy(d.end),a.end.copy(d.end)),!0;if(2!==t)return!1;const e=y(r,h,p);if(1===e&&this.containsPoint(p.end))return a&&(a.start.copy(p.end),a.end.copy(p.end)),!0;if(2!==e)return!1;if(d.delta(c),p.delta(l),c.dot(l)<0){let t=p.start;p.start=p.end,p.end=t}const n=d.start.dot(c),o=d.end.dot(c),s=p.start.dot(c),i=p.end.dot(c);return(n===i||s===o||o<s!=n<i)&&(a&&(u.subVectors(d.start,p.start),u.dot(c)>0?a.start.copy(d.start):a.start.copy(p.start),u.subVectors(d.end,p.end),u.dot(c)<0?a.end.copy(d.end):a.end.copy(p.end)),!0)}}}(),j.prototype.distanceToPoint=function(){const t=new r.Pq0;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),j.prototype.distanceToTriangle=function(){const t=new r.Pq0,e=new r.Pq0,n=["a","b","c"],o=new r.cZY,s=new r.cZY;return function(r,i=null,a=null){const c=i||a?o:null;if(this.intersectsTriangle(r,c))return(i||a)&&(i&&c.getCenter(i),a&&c.getCenter(a)),0;let l=1/0;for(let e=0;e<3;e++){let o;const s=n[e],c=r[s];this.closestPointToPoint(c,t),o=c.distanceToSquared(t),o<l&&(l=o,i&&i.copy(t),a&&a.copy(c));const u=this[s];r.closestPointToPoint(u,t),o=u.distanceToSquared(t),o<l&&(l=o,i&&i.copy(u),a&&a.copy(t))}for(let c=0;c<3;c++){const u=n[c],f=n[(c+1)%3];o.set(this[u],this[f]);for(let c=0;c<3;c++){const u=n[c],f=n[(c+1)%3];s.set(r[u],r[f]),Z(o,s,t,e);const d=t.distanceToSquared(e);d<l&&(l=d,i&&i.copy(t),a&&a.copy(e))}}return Math.sqrt(l)}}();class D{constructor(t,e,n){this.isOrientedBox=!0,this.min=new r.Pq0,this.max=new r.Pq0,this.matrix=new r.kn4,this.invMatrix=new r.kn4,this.points=new Array(8).fill().map(()=>new r.Pq0),this.satAxes=new Array(3).fill().map(()=>new r.Pq0),this.satBounds=new Array(3).fill().map(()=>new k),this.alignedSatBounds=new Array(3).fill().map(()=>new k),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),n&&this.matrix.copy(n)}set(t,e,n){this.min.copy(t),this.max.copy(e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}D.prototype.update=function(){const t=this.matrix,e=this.min,n=this.max,r=this.points;for(let o=0;o<=1;o++)for(let s=0;s<=1;s++)for(let i=0;i<=1;i++){const a=r[1*o|2*s|4*i];a.x=o?n.x:e.x,a.y=s?n.y:e.y,a.z=i?n.z:e.z,a.applyMatrix4(t)}const o=this.satBounds,s=this.satAxes,i=r[0];for(let t=0;t<3;t++){const e=s[t],n=o[t],a=r[1<<t];e.subVectors(i,a),n.setFromPoints(e,r)}const a=this.alignedSatBounds;a[0].setFromPointsField(r,"x"),a[1].setFromPointsField(r,"y"),a[2].setFromPointsField(r,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1},D.prototype.intersectsBox=function(){const t=new k;return function(e){this.needsUpdate&&this.update();const n=e.min,r=e.max,o=this.satBounds,s=this.satAxes,i=this.alignedSatBounds;if(t.min=n.x,t.max=r.x,i[0].isSeparated(t))return!1;if(t.min=n.y,t.max=r.y,i[1].isSeparated(t))return!1;if(t.min=n.z,t.max=r.z,i[2].isSeparated(t))return!1;for(let n=0;n<3;n++){const r=s[n],i=o[n];if(t.setFromBox(r,e),i.isSeparated(t))return!1}return!0}}(),D.prototype.intersectsTriangle=function(){const t=new j,e=new Array(3),n=new k,o=new k,s=new r.Pq0;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(t.copy(r),t.update(),r=t);const i=this.satBounds,a=this.satAxes;e[0]=r.a,e[1]=r.b,e[2]=r.c;for(let t=0;t<3;t++){const r=i[t],o=a[t];if(n.setFromPoints(o,e),r.isSeparated(n))return!1}const c=r.satBounds,l=r.satAxes,u=this.points;for(let t=0;t<3;t++){const e=c[t],r=l[t];if(n.setFromPoints(r,u),e.isSeparated(n))return!1}for(let t=0;t<3;t++){const r=a[t];for(let t=0;t<4;t++){const i=l[t];if(s.crossVectors(r,i),n.setFromPoints(s,e),o.setFromPoints(s,u),n.isSeparated(o))return!1}}return!0}}(),D.prototype.closestPointToPoint=function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e},D.prototype.distanceToPoint=function(){const t=new r.Pq0;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),D.prototype.distanceToBox=function(){const t=["x","y","z"],e=new Array(12).fill().map(()=>new r.cZY),n=new Array(12).fill().map(()=>new r.cZY),o=new r.Pq0,s=new r.Pq0;return function(r,i=0,a=null,c=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(a||c)&&(r.getCenter(s),this.closestPointToPoint(s,o),r.closestPointToPoint(o,s),a&&a.copy(o),c&&c.copy(s)),0;const l=i*i,u=r.min,f=r.max,d=this.points;let p=1/0;for(let t=0;t<8;t++){const e=d[t];s.copy(e).clamp(u,f);const n=e.distanceToSquared(s);if(n<p&&(p=n,a&&a.copy(e),c&&c.copy(s),n<l))return Math.sqrt(n)}let h=0;for(let r=0;r<3;r++)for(let o=0;o<=1;o++)for(let s=0;s<=1;s++){const i=(r+1)%3,a=(r+2)%3,c=1<<r|o<<i|s<<a,l=d[o<<i|s<<a],p=d[c];e[h].set(l,p);const y=t[r],g=t[i],m=t[a],x=n[h],w=x.start,B=x.end;w[y]=u[y],w[g]=o?u[g]:f[g],w[m]=s?u[m]:f[g],B[y]=f[y],B[g]=o?u[g]:f[g],B[m]=s?u[m]:f[g],h++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let n=0;n<=1;n++){s.x=t?f.x:u.x,s.y=e?f.y:u.y,s.z=n?f.z:u.z,this.closestPointToPoint(s,o);const r=s.distanceToSquared(o);if(r<p&&(p=r,a&&a.copy(o),c&&c.copy(s),r<l))return Math.sqrt(r)}for(let t=0;t<12;t++){const r=e[t];for(let t=0;t<12;t++){const e=n[t];Z(r,e,o,s);const i=o.distanceToSquared(s);if(i<p&&(p=i,a&&a.copy(o),c&&c.copy(s),i<l))return Math.sqrt(i)}}return Math.sqrt(p)}}();class G{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return 0===t.length?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class L extends G{constructor(){super(()=>new j)}}const W=new L,$=new class{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=n=>{e&&t.push(e),e=n,this.float32Array=new Float32Array(n),this.uint16Array=new Uint16Array(n),this.uint32Array=new Uint32Array(n)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,0!==t.length&&this.setBuffer(t.pop())}}};let K,Q;const J=[],tt=new G(()=>new r.NRn);function et(t,e,n,r,o,s){K=tt.getPrimitive(),Q=tt.getPrimitive(),J.push(K,Q),$.setBuffer(t._roots[e]);const i=nt(0,t.geometry,n,r,o,s);$.clearBuffer(),tt.releasePrimitive(K),tt.releasePrimitive(Q),J.pop(),J.pop();const a=J.length;return a>0&&(Q=J[a-1],K=J[a-2]),i}function nt(t,e,n,r,o=null,s=0,i=0){const{float32Array:a,uint16Array:c,uint32Array:l}=$;let u=2*t;if(T(u,c)){const f=v(t,l),p=M(u,c);return d(t,a,K),r(f,p,!1,i,s+t,K)}{const h=q(t),y=U(t,l);let g,m,x,w,B=h,b=y;if(o&&(x=K,w=Q,d(B,a,x),d(b,a,w),g=o(x),m=o(w),m<g)){B=y,b=h;const R=g;g=m,m=R,x=w}x||(x=K,d(B,a,x));const P=n(x,T(2*B,c),g,i+1,s+B);let A;if(2===P){const z=_(B);A=r(z,F(B)-z,!0,i+1,s+B,x)}else A=P&&nt(B,e,n,r,o,s,i+1);if(A)return!0;w=Q,d(b,a,w);const S=n(w,T(2*b,c),m,i+1,s+b);let I;if(2===S){const V=_(b);I=r(V,F(b)-V,!0,i+1,s+b,w)}else I=S&&nt(b,e,n,r,o,s,i+1);return!!I;function _(t){const{uint16Array:e,uint32Array:n}=$;let r=2*t;for(;!T(r,e);)r=2*(t=q(t));return v(t,n)}function F(t){const{uint16Array:e,uint32Array:n}=$;let r=2*t;for(;!T(r,e);)r=2*(t=U(t,n));return v(t,n)+M(r,e)}}}const rt=new r.Pq0,ot=new r.Pq0,st=parseInt(r.sPf)>=169,it=new r.Pq0,at=new r.Pq0,ct=new r.Pq0,lt=new r.I9Y,ut=new r.I9Y,ft=new r.I9Y,dt=new r.Pq0,pt=new r.Pq0,ht=new r.Pq0,yt=new r.Pq0;function gt(t,e,n,o,s,i,a){const c=3*o;let l=c+0,u=c+1,f=c+2;const d=t.index;t.index&&(l=d.getX(l),u=d.getX(u),f=d.getX(f));const{position:p,normal:h,uv:y,uv1:g}=t.attributes,m=function(t,e,n,o,s,i,a,c,l,u,f){it.fromBufferAttribute(e,i),at.fromBufferAttribute(e,a),ct.fromBufferAttribute(e,c);const d=function(t,e,n,o,s,i,a,c){let l;if(l=i===r.hsX?t.intersectTriangle(o,n,e,!0,s):t.intersectTriangle(e,n,o,i!==r.$EB,s),null===l)return null;const u=t.origin.distanceTo(s);return u<a||u>c?null:{distance:u,point:s.clone()}}(t,it,at,ct,yt,l,u,f);if(d){const e=new r.Pq0;r.lMl.getBarycoord(yt,it,at,ct,e),o&&(lt.fromBufferAttribute(o,i),ut.fromBufferAttribute(o,a),ft.fromBufferAttribute(o,c),d.uv=r.lMl.getInterpolation(yt,it,at,ct,lt,ut,ft,new r.I9Y)),s&&(lt.fromBufferAttribute(s,i),ut.fromBufferAttribute(s,a),ft.fromBufferAttribute(s,c),d.uv1=r.lMl.getInterpolation(yt,it,at,ct,lt,ut,ft,new r.I9Y)),n&&(dt.fromBufferAttribute(n,i),pt.fromBufferAttribute(n,a),ht.fromBufferAttribute(n,c),d.normal=r.lMl.getInterpolation(yt,it,at,ct,dt,pt,ht,new r.Pq0),d.normal.dot(t.direction)>0&&d.normal.multiplyScalar(-1));const l={a:i,b:a,c,normal:new r.Pq0,materialIndex:0};r.lMl.getNormal(it,at,ct,l.normal),d.face=l,d.faceIndex=i,st&&(d.barycoord=e)}return d}(n,p,h,y,g,l,u,f,e,i,a);return m?(m.faceIndex=o,s&&s.push(m),m):null}function mt(t,e,n,r){const o=t.a,s=t.b,i=t.c;let a=e,c=e+1,l=e+2;n&&(a=n.getX(a),c=n.getX(c),l=n.getX(l)),o.x=r.getX(a),o.y=r.getY(a),o.z=r.getZ(a),s.x=r.getX(c),s.y=r.getY(c),s.z=r.getZ(c),i.x=r.getX(l),i.y=r.getY(l),i.z=r.getZ(l)}function xt(t,e,n,r,o,s,i){const{geometry:a}=n,{index:c}=a,l=a.attributes.position;for(let n=t,a=e+t;n<a;n++){let t;if(t=n,mt(i,3*t,c,l),i.needsUpdate=!0,r(i,t,o,s))return!0}return!1}function wt(t,e=null){e&&Array.isArray(e)&&(e=new Set(e));const n=t.geometry,r=n.index?n.index.array:null,o=n.attributes.position;let i,a,c,l,u=0;const f=t._roots;for(let t=0,e=f.length;t<e;t++)i=f[t],a=new Uint32Array(i),c=new Uint16Array(i),l=new Float32Array(i),d(0,u),u+=i.byteLength;function d(t,n,i=!1){const u=2*t;if(c[u+15]===s){const e=a[t+6];let n=1/0,s=1/0,i=1/0,f=-1/0,d=-1/0,p=-1/0;for(let t=3*e,a=3*(e+c[u+14]);t<a;t++){let e=r[t];const a=o.getX(e),c=o.getY(e),l=o.getZ(e);a<n&&(n=a),a>f&&(f=a),c<s&&(s=c),c>d&&(d=c),l<i&&(i=l),l>p&&(p=l)}return(l[t+0]!==n||l[t+1]!==s||l[t+2]!==i||l[t+3]!==f||l[t+4]!==d||l[t+5]!==p)&&(l[t+0]=n,l[t+1]=s,l[t+2]=i,l[t+3]=f,l[t+4]=d,l[t+5]=p,!0)}{const r=t+8,o=a[t+6],s=r+n,c=o+n;let u=i,f=!1,p=!1;e?u||(f=e.has(s),p=e.has(c),u=!f&&!p):(f=!0,p=!0);const h=u||p;let y=!1;(u||f)&&(y=d(r,n,u));let g=!1;h&&(g=d(o,n,u));const m=y||g;if(m)for(let e=0;e<3;e++){const n=r+e,s=o+e,i=l[n],a=l[n+3],c=l[s],u=l[s+3];l[t+e]=i<c?i:c,l[t+e+3]=a>u?a:u}return m}}}function Bt(t,e,n,r,o){let s,i,a,c,l,u;const f=1/n.direction.x,d=1/n.direction.y,p=1/n.direction.z,h=n.origin.x,y=n.origin.y,g=n.origin.z;let m=e[t],x=e[t+3],w=e[t+1],B=e[t+3+1],b=e[t+2],P=e[t+3+2];return f>=0?(s=(m-h)*f,i=(x-h)*f):(s=(x-h)*f,i=(m-h)*f),d>=0?(a=(w-y)*d,c=(B-y)*d):(a=(B-y)*d,c=(w-y)*d),!(s>c||a>i)&&((a>s||isNaN(s))&&(s=a),(c<i||isNaN(i))&&(i=c),p>=0?(l=(b-g)*p,u=(P-g)*p):(l=(P-g)*p,u=(b-g)*p),!(s>u||l>i)&&((l>s||s!=s)&&(s=l),(u<i||i!=i)&&(i=u),s<=o&&i>=r))}function bt(t,e,n,r,o,s,i){$.setBuffer(t._roots[e]),Pt(0,t,n,r,o,s,i),$.clearBuffer()}function Pt(t,e,n,r,o,s,i){const{float32Array:a,uint16Array:c,uint32Array:l}=$,u=2*t;if(T(u,c))!function(t,e,n,r,o,s,i,a){const{geometry:c,_indirectBuffer:l}=t;for(let t=r,l=r+o;t<l;t++)gt(c,e,n,t,s,i,a)}(e,n,r,v(t,l),M(u,c),o,s,i);else{const c=q(t);Bt(c,a,r,s,i)&&Pt(c,e,n,r,o,s,i);const u=U(t,l);Bt(u,a,r,s,i)&&Pt(u,e,n,r,o,s,i)}}const At=["x","y","z"];function Tt(t,e,n,r,o,s){$.setBuffer(t._roots[e]);const i=vt(0,t,n,r,o,s);return $.clearBuffer(),i}function vt(t,e,n,r,o,s){const{float32Array:i,uint16Array:a,uint32Array:c}=$;let l=2*t;if(T(l,a))return function(t,e,n,r,o,s,i){const{geometry:a,_indirectBuffer:c}=t;let l=1/0,u=null;for(let t=r,c=r+o;t<c;t++){let r;r=gt(a,e,n,t,null,s,i),r&&r.distance<l&&(u=r,l=r.distance)}return u}(e,n,r,v(t,c),M(l,a),o,s);{const a=S(t,c),l=At[a],u=r.direction[l]>=0;let f,d;u?(f=q(t),d=U(t,c)):(f=U(t,c),d=q(t));const p=Bt(f,i,r,o,s)?vt(f,e,n,r,o,s):null;if(p){const t=p.point[l];if(u?t<=i[d+a]:t>=i[d+a+3])return p}const h=Bt(d,i,r,o,s)?vt(d,e,n,r,o,s):null;return p&&h?p.distance<=h.distance?p:h:p||h||null}}const Mt=new r.NRn,qt=new j,Ut=new j,St=new r.kn4,It=new D,_t=new D;function Ft(t,e,n,r){$.setBuffer(t._roots[e]);const o=Rt(0,t,n,r);return $.clearBuffer(),o}function Rt(t,e,n,r,o=null){const{float32Array:s,uint16Array:i,uint32Array:a}=$;let c=2*t;if(null===o&&(n.boundingBox||n.computeBoundingBox(),It.set(n.boundingBox.min,n.boundingBox.max,r),o=It),!T(c,i)){const i=t+8,c=a[t+6];return d(i,s,Mt),o.intersectsBox(Mt)&&Rt(i,e,n,r,o)?!0:(d(c,s,Mt),!(!o.intersectsBox(Mt)||!Rt(c,e,n,r,o)))}{const o=e.geometry,l=o.index,u=o.attributes.position,f=n.index,p=n.attributes.position,h=v(t,a),y=M(c,i);if(St.copy(r).invert(),n.boundsTree)return d(t,s,_t),_t.matrix.copy(St),_t.needsUpdate=!0,n.boundsTree.shapecast({intersectsBounds:t=>_t.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(r),t.b.applyMatrix4(r),t.c.applyMatrix4(r),t.needsUpdate=!0;for(let e=3*h,n=3*(y+h);e<n;e+=3)if(mt(Ut,e,l,u),Ut.needsUpdate=!0,t.intersectsTriangle(Ut))return!0;return!1}});for(let t=3*h,e=3*(y+h);t<e;t+=3){mt(qt,t,l,u),qt.a.applyMatrix4(St),qt.b.applyMatrix4(St),qt.c.applyMatrix4(St),qt.needsUpdate=!0;for(let t=0,e=f.count;t<e;t+=3)if(mt(Ut,t,f,p),Ut.needsUpdate=!0,qt.intersectsTriangle(Ut))return!0}}}const zt=new r.kn4,Vt=new D,Ct=new D,Et=new r.Pq0,Nt=new r.Pq0,Yt=new r.Pq0,kt=new r.Pq0;function Ot(t,e,n,r={},o={},s=0,i=1/0){e.boundingBox||e.computeBoundingBox(),Vt.set(e.boundingBox.min,e.boundingBox.max,n),Vt.needsUpdate=!0;const a=t.geometry,l=a.attributes.position,u=a.index,f=e.attributes.position,d=e.index,p=W.getPrimitive(),h=W.getPrimitive();let y=Et,g=Nt,m=null,x=null;o&&(m=Yt,x=kt);let w=1/0,B=null,b=null;return zt.copy(n).invert(),Ct.matrix.copy(zt),t.shapecast({boundsTraverseOrder:t=>Vt.distanceToBox(t),intersectsBounds:(t,e,n)=>n<w&&n<i&&(e&&(Ct.min.copy(t.min),Ct.max.copy(t.max),Ct.needsUpdate=!0),!0),intersectsRange:(t,r)=>{if(e.boundsTree)return e.boundsTree.shapecast({boundsTraverseOrder:t=>Ct.distanceToBox(t),intersectsBounds:(t,e,n)=>n<w&&n<i,intersectsRange:(e,o)=>{for(let i=e,a=e+o;i<a;i++){mt(h,3*i,d,f),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let e=t,n=t+r;e<n;e++){mt(p,3*e,u,l),p.needsUpdate=!0;const t=p.distanceToTriangle(h,y,m);if(t<w&&(g.copy(y),x&&x.copy(m),w=t,B=e,b=i),t<s)return!0}}}});for(let o=0,i=c(e);o<i;o++){mt(h,3*o,d,f),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let e=t,n=t+r;e<n;e++){mt(p,3*e,u,l),p.needsUpdate=!0;const t=p.distanceToTriangle(h,y,m);if(t<w&&(g.copy(y),x&&x.copy(m),w=t,B=e,b=o),t<s)return!0}}}}),W.releasePrimitive(p),W.releasePrimitive(h),w===1/0?null:(r.point?r.point.copy(g):r.point=g.clone(),r.distance=w,r.faceIndex=B,o&&(o.point?o.point.copy(x):o.point=x.clone(),o.point.applyMatrix4(zt),g.applyMatrix4(zt),o.distance=g.sub(o.point).length(),o.faceIndex=b),r)}function Zt(t,e,n,r,o,s,i){const{geometry:a}=n,{index:c}=a,l=a.attributes.position;for(let a=t,u=e+t;a<u;a++){let t;if(t=n.resolveTriangleIndex(a),mt(i,3*t,c,l),i.needsUpdate=!0,r(i,t,o,s))return!0}return!1}function Ht(t,e=null){e&&Array.isArray(e)&&(e=new Set(e));const n=t.geometry,r=n.index?n.index.array:null,o=n.attributes.position;let i,a,c,l,u=0;const f=t._roots;for(let t=0,e=f.length;t<e;t++)i=f[t],a=new Uint32Array(i),c=new Uint16Array(i),l=new Float32Array(i),d(0,u),u+=i.byteLength;function d(n,i,u=!1){const f=2*n;if(c[f+15]===s){const e=a[n+6];let s=1/0,i=1/0,u=1/0,d=-1/0,p=-1/0,h=-1/0;for(let n=e,a=e+c[f+14];n<a;n++){const e=3*t.resolveTriangleIndex(n);for(let t=0;t<3;t++){let n=e+t;n=r?r[n]:n;const a=o.getX(n),c=o.getY(n),l=o.getZ(n);a<s&&(s=a),a>d&&(d=a),c<i&&(i=c),c>p&&(p=c),l<u&&(u=l),l>h&&(h=l)}}return(l[n+0]!==s||l[n+1]!==i||l[n+2]!==u||l[n+3]!==d||l[n+4]!==p||l[n+5]!==h)&&(l[n+0]=s,l[n+1]=i,l[n+2]=u,l[n+3]=d,l[n+4]=p,l[n+5]=h,!0)}{const t=n+8,r=a[n+6],o=t+i,s=r+i;let c=u,f=!1,p=!1;e?c||(f=e.has(o),p=e.has(s),c=!f&&!p):(f=!0,p=!0);const h=c||p;let y=!1;(c||f)&&(y=d(t,i,c));let g=!1;h&&(g=d(r,i,c));const m=y||g;if(m)for(let e=0;e<3;e++){const o=t+e,s=r+e,i=l[o],a=l[o+3],c=l[s],u=l[s+3];l[n+e]=i<c?i:c,l[n+e+3]=a>u?a:u}return m}}}function Xt(t,e,n,r,o,s,i){$.setBuffer(t._roots[e]),jt(0,t,n,r,o,s,i),$.clearBuffer()}function jt(t,e,n,r,o,s,i){const{float32Array:a,uint16Array:c,uint32Array:l}=$,u=2*t;if(T(u,c))!function(t,e,n,r,o,s,i,a){const{geometry:c,_indirectBuffer:l}=t;for(let t=r,u=r+o;t<u;t++)gt(c,e,n,l?l[t]:t,s,i,a)}(e,n,r,v(t,l),M(u,c),o,s,i);else{const c=q(t);Bt(c,a,r,s,i)&&jt(c,e,n,r,o,s,i);const u=U(t,l);Bt(u,a,r,s,i)&&jt(u,e,n,r,o,s,i)}}const Dt=["x","y","z"];function Gt(t,e,n,r,o,s){$.setBuffer(t._roots[e]);const i=Lt(0,t,n,r,o,s);return $.clearBuffer(),i}function Lt(t,e,n,r,o,s){const{float32Array:i,uint16Array:a,uint32Array:c}=$;let l=2*t;if(T(l,a))return function(t,e,n,r,o,s,i){const{geometry:a,_indirectBuffer:c}=t;let l=1/0,u=null;for(let t=r,f=r+o;t<f;t++){let r;r=gt(a,e,n,c?c[t]:t,null,s,i),r&&r.distance<l&&(u=r,l=r.distance)}return u}(e,n,r,v(t,c),M(l,a),o,s);{const a=S(t,c),l=Dt[a],u=r.direction[l]>=0;let f,d;u?(f=q(t),d=U(t,c)):(f=U(t,c),d=q(t));const p=Bt(f,i,r,o,s)?Lt(f,e,n,r,o,s):null;if(p){const t=p.point[l];if(u?t<=i[d+a]:t>=i[d+a+3])return p}const h=Bt(d,i,r,o,s)?Lt(d,e,n,r,o,s):null;return p&&h?p.distance<=h.distance?p:h:p||h||null}}const Wt=new r.NRn,$t=new j,Kt=new j,Qt=new r.kn4,Jt=new D,te=new D;function ee(t,e,n,r){$.setBuffer(t._roots[e]);const o=ne(0,t,n,r);return $.clearBuffer(),o}function ne(t,e,n,r,o=null){const{float32Array:s,uint16Array:i,uint32Array:a}=$;let c=2*t;if(null===o&&(n.boundingBox||n.computeBoundingBox(),Jt.set(n.boundingBox.min,n.boundingBox.max,r),o=Jt),!T(c,i)){const i=t+8,c=a[t+6];return d(i,s,Wt),o.intersectsBox(Wt)&&ne(i,e,n,r,o)?!0:(d(c,s,Wt),!(!o.intersectsBox(Wt)||!ne(c,e,n,r,o)))}{const o=e.geometry,l=o.index,u=o.attributes.position,f=n.index,p=n.attributes.position,h=v(t,a),y=M(c,i);if(Qt.copy(r).invert(),n.boundsTree)return d(t,s,te),te.matrix.copy(Qt),te.needsUpdate=!0,n.boundsTree.shapecast({intersectsBounds:t=>te.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(r),t.b.applyMatrix4(r),t.c.applyMatrix4(r),t.needsUpdate=!0;for(let n=h,r=y+h;n<r;n++)if(mt(Kt,3*e.resolveTriangleIndex(n),l,u),Kt.needsUpdate=!0,t.intersectsTriangle(Kt))return!0;return!1}});for(let t=h,n=y+h;t<n;t++){const n=e.resolveTriangleIndex(t);mt($t,3*n,l,u),$t.a.applyMatrix4(Qt),$t.b.applyMatrix4(Qt),$t.c.applyMatrix4(Qt),$t.needsUpdate=!0;for(let t=0,e=f.count;t<e;t+=3)if(mt(Kt,t,f,p),Kt.needsUpdate=!0,$t.intersectsTriangle(Kt))return!0}}}const re=new r.kn4,oe=new D,se=new D,ie=new r.Pq0,ae=new r.Pq0,ce=new r.Pq0,le=new r.Pq0;function ue(t,e,n,r={},o={},s=0,i=1/0){e.boundingBox||e.computeBoundingBox(),oe.set(e.boundingBox.min,e.boundingBox.max,n),oe.needsUpdate=!0;const a=t.geometry,l=a.attributes.position,u=a.index,f=e.attributes.position,d=e.index,p=W.getPrimitive(),h=W.getPrimitive();let y=ie,g=ae,m=null,x=null;o&&(m=ce,x=le);let w=1/0,B=null,b=null;return re.copy(n).invert(),se.matrix.copy(re),t.shapecast({boundsTraverseOrder:t=>oe.distanceToBox(t),intersectsBounds:(t,e,n)=>n<w&&n<i&&(e&&(se.min.copy(t.min),se.max.copy(t.max),se.needsUpdate=!0),!0),intersectsRange:(r,o)=>{if(e.boundsTree){const a=e.boundsTree;return a.shapecast({boundsTraverseOrder:t=>se.distanceToBox(t),intersectsBounds:(t,e,n)=>n<w&&n<i,intersectsRange:(e,i)=>{for(let c=e,P=e+i;c<P;c++){const e=a.resolveTriangleIndex(c);mt(h,3*e,d,f),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let e=r,n=r+o;e<n;e++){const n=t.resolveTriangleIndex(e);mt(p,3*n,u,l),p.needsUpdate=!0;const r=p.distanceToTriangle(h,y,m);if(r<w&&(g.copy(y),x&&x.copy(m),w=r,B=e,b=c),r<s)return!0}}}})}for(let i=0,a=c(e);i<a;i++){mt(h,3*i,d,f),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let e=r,n=r+o;e<n;e++){const n=t.resolveTriangleIndex(e);mt(p,3*n,u,l),p.needsUpdate=!0;const r=p.distanceToTriangle(h,y,m);if(r<w&&(g.copy(y),x&&x.copy(m),w=r,B=e,b=i),r<s)return!0}}}}),W.releasePrimitive(p),W.releasePrimitive(h),w===1/0?null:(r.point?r.point.copy(g):r.point=g.clone(),r.distance=w,r.faceIndex=B,o&&(o.point?o.point.copy(x):o.point=x.clone(),o.point.applyMatrix4(re),g.applyMatrix4(re),o.distance=g.sub(o.point).length(),o.faceIndex=b),r)}const fe=new $.constructor,de=new $.constructor,pe=new G(()=>new r.NRn),he=new r.NRn,ye=new r.NRn,ge=new r.NRn,me=new r.NRn;let xe=!1;function we(t,e,n,r,o,s=0,i=0,a=0,c=0,l=null,u=!1){let f,p;u?(f=de,p=fe):(f=fe,p=de);const h=f.float32Array,y=f.uint32Array,g=f.uint16Array,m=p.float32Array,x=p.uint32Array,w=p.uint16Array,B=2*e,b=T(2*t,g),P=T(B,w);let A=!1;if(P&&b)A=u?o(v(e,x),M(2*e,w),v(t,y),M(2*t,g),c,i+e,a,s+t):o(v(t,y),M(2*t,g),v(e,x),M(2*e,w),a,s+t,c,i+e);else if(P){const l=pe.getPrimitive();d(e,m,l),l.applyMatrix4(n);const f=q(t),p=U(t,y);d(f,h,he),d(p,h,ye);const g=l.intersectsBox(he),x=l.intersectsBox(ye);A=g&&we(e,f,r,n,o,i,s,c,a+1,l,!u)||x&&we(e,p,r,n,o,i,s,c,a+1,l,!u),pe.releasePrimitive(l)}else{const f=q(e),p=U(e,x);d(f,m,ge),d(p,m,me);const g=l.intersectsBox(ge),w=l.intersectsBox(me);if(g&&w)A=we(t,f,n,r,o,s,i,a,c+1,l,u)||we(t,p,n,r,o,s,i,a,c+1,l,u);else if(g)if(b)A=we(t,f,n,r,o,s,i,a,c+1,l,u);else{const e=pe.getPrimitive();e.copy(ge).applyMatrix4(n);const l=q(t),p=U(t,y);d(l,h,he),d(p,h,ye);const g=e.intersectsBox(he),m=e.intersectsBox(ye);A=g&&we(f,l,r,n,o,i,s,c,a+1,e,!u)||m&&we(f,p,r,n,o,i,s,c,a+1,e,!u),pe.releasePrimitive(e)}else if(w)if(b)A=we(t,p,n,r,o,s,i,a,c+1,l,u);else{const e=pe.getPrimitive();e.copy(me).applyMatrix4(n);const l=q(t),f=U(t,y);d(l,h,he),d(f,h,ye);const g=e.intersectsBox(he),m=e.intersectsBox(ye);A=g&&we(p,l,r,n,o,i,s,c,a+1,e,!u)||m&&we(p,f,r,n,o,i,s,c,a+1,e,!u),pe.releasePrimitive(e)}}return A}const Be=new D,be=new r.NRn,Pe={strategy:0,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null};class Ae{static serialize(t,e={}){e={cloneBuffers:!0,...e};const n=t.geometry,r=t._roots,o=t._indirectBuffer,s=n.getIndex();let i;return i=e.cloneBuffers?{roots:r.map(t=>t.slice()),index:s?s.array.slice():null,indirectBuffer:o?o.slice():null}:{roots:r,index:s?s.array:null,indirectBuffer:o},i}static deserialize(t,e,n={}){n={setIndex:!0,indirect:Boolean(t.indirectBuffer),...n};const{index:o,roots:s,indirectBuffer:i}=t,c=new Ae(e,{...n,[a]:!0});if(c._roots=s,c._indirectBuffer=i||null,n.setIndex){const n=e.getIndex();if(null===n){const n=new r.THS(t.index,1,!1);e.setIndex(n)}else n.array!==o&&(n.array.set(o),n.needsUpdate=!0)}return c}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(!t.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");if((e=Object.assign({...Pe,[a]:!1},e)).useSharedArrayBuffer&&"undefined"==typeof SharedArrayBuffer)throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[a]||(Y(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new r.NRn))),this.resolveTriangleIndex=e.indirect?t=>this._indirectBuffer[t]:t=>t}refit(t=null){return(this.indirect?Ht:wt)(this,t)}traverse(t,e=0){const n=this._roots[e],r=new Uint32Array(n),o=new Uint16Array(n);!function e(i,a=0){const c=2*i,l=o[c+15]===s;if(l){const e=r[i+6],s=o[c+14];t(a,l,new Float32Array(n,4*i,6),e,s)}else{const o=i+8,s=r[i+6],c=r[i+7];t(a,l,new Float32Array(n,4*i,6),c)||(e(o,a+1),e(s,a+1))}}(0)}raycast(t,e=r.hB5,n=0,o=1/0){const s=this._roots,i=this.geometry,a=[],c=e.isMaterial,l=Array.isArray(e),u=i.groups,f=c?e.side:e,d=this.indirect?Xt:bt;for(let r=0,i=s.length;r<i;r++){const s=l?e[u[r].materialIndex].side:f,i=a.length;if(d(this,r,s,t,a,n,o),l){const t=u[r].materialIndex;for(let e=i,n=a.length;e<n;e++)a[e].face.materialIndex=t}}return a}raycastFirst(t,e=r.hB5,n=0,o=1/0){const s=this._roots,i=this.geometry,a=e.isMaterial,c=Array.isArray(e);let l=null;const u=i.groups,f=a?e.side:e,d=this.indirect?Gt:Tt;for(let r=0,i=s.length;r<i;r++){const s=d(this,r,c?e[u[r].materialIndex].side:f,t,n,o);null!=s&&(null==l||s.distance<l.distance)&&(l=s,c&&(s.face.materialIndex=u[r].materialIndex))}return l}intersectsGeometry(t,e){let n=!1;const r=this._roots,o=this.indirect?ee:Ft;for(let s=0,i=r.length;s<i&&(n=o(this,s,t,e),!n);s++);return n}shapecast(t){const e=W.getPrimitive(),n=this.indirect?Zt:xt;let{boundsTraverseOrder:r,intersectsBounds:o,intersectsRange:s,intersectsTriangle:i}=t;if(s&&i){const t=s;s=(r,o,s,a,c)=>!!t(r,o,s,a,c)||n(r,o,this,i,s,a,e)}else s||(s=i?(t,r,o,s)=>n(t,r,this,i,o,s,e):(t,e,n)=>n);let a=!1,c=0;const l=this._roots;for(let t=0,e=l.length;t<e;t++){const e=l[t];if(a=et(this,t,o,s,r,c),a)break;c+=e.byteLength}return W.releasePrimitive(e),a}bvhcast(t,e,n){let{intersectsRanges:o,intersectsTriangles:s}=n;const i=W.getPrimitive(),a=this.geometry.index,c=this.geometry.attributes.position,l=this.indirect?t=>{const e=this.resolveTriangleIndex(t);mt(i,3*e,a,c)}:t=>{mt(i,3*t,a,c)},u=W.getPrimitive(),f=t.geometry.index,p=t.geometry.attributes.position,h=t.indirect?e=>{const n=t.resolveTriangleIndex(e);mt(u,3*n,f,p)}:t=>{mt(u,3*t,f,p)};if(s){const t=(t,n,r,o,a,c,f,d)=>{for(let p=r,y=r+o;p<y;p++){h(p),u.a.applyMatrix4(e),u.b.applyMatrix4(e),u.c.applyMatrix4(e),u.needsUpdate=!0;for(let e=t,r=t+n;e<r;e++)if(l(e),i.needsUpdate=!0,s(i,u,e,p,a,c,f,d))return!0}return!1};if(o){const e=o;o=function(n,r,o,s,i,a,c,l){return!!e(n,r,o,s,i,a,c,l)||t(n,r,o,s,i,a,c,l)}}else o=t}return function(t,e,n,o){if(xe)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");xe=!0;const s=t._roots,i=e._roots;let a,c=0,l=0;const u=(new r.kn4).copy(n).invert();for(let t=0,e=s.length;t<e;t++){fe.setBuffer(s[t]),l=0;const e=pe.getPrimitive();d(I(0),fe.float32Array,e),e.applyMatrix4(u);for(let t=0,r=i.length;t<r&&(de.setBuffer(i[t]),a=we(0,0,n,u,o,c,l,0,0,e),de.clearBuffer(),l+=i[t].length,!a);t++);if(pe.releasePrimitive(e),fe.clearBuffer(),c+=s[t].length,a)break}return xe=!1,a}(this,t,e,o)}intersectsBox(t,e){return Be.set(t.min,t.max,e),Be.needsUpdate=!0,this.shapecast({intersectsBounds:t=>Be.intersectsBox(t),intersectsTriangle:t=>Be.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},r={},o=0,s=1/0){return(this.indirect?ue:Ot)(this,t,e,n,r,o,s)}closestPointToPoint(t,e={},n=0,r=1/0){return function(t,e,n={},r=0,o=1/0){const s=r*r,i=o*o;let a=1/0,c=null;if(t.shapecast({boundsTraverseOrder:t=>(rt.copy(e).clamp(t.min,t.max),rt.distanceToSquared(e)),intersectsBounds:(t,e,n)=>n<a&&n<i,intersectsTriangle:(t,n)=>{t.closestPointToPoint(e,rt);const r=e.distanceToSquared(rt);return r<a&&(ot.copy(rt),a=r,c=n),r<s}}),a===1/0)return null;const l=Math.sqrt(a);return n.point?n.point.copy(ot):n.point=ot.clone(),n.distance=l,n.faceIndex=c,n}(this,t,e,n,r)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(e=>{d(0,new Float32Array(e),be),t.union(be)}),t}}}}]);